在访问stack.top()时没有确定栈非空
全局变量在声明的时候它是一个连续的内存当有数组越界了的话，会连累到紧挨它内存的变量
局部变量千万不要和全局变量重复不然会冲突导致两者的值都不稳定
如果有多组测试的话clear一定要放在建图之前,注意跑最短路之前先初始dis全为inf
局部变量不可以太大不然会栈溢出导致程序崩溃

二维降为一维后再映射回去的时候写法为：
x = (u - 1) / m + 1 , y = (u - 1) % m + 1（1基，起始为1，1）
x = u / m , y = u % m （0基，起始为0，0）

二维降为一维的写法为：
u = (x - 1) * m + y;
而不是：u = (x - 1) * n + y

在做向上取整时注意精度丢失的问题：
正确写法：
ll x;
if((pq.top() - op) % (fg ? (cnt + 1) : cnt))x = (pq.top() - op) / (fg ? (cnt + 1) : cnt) + 1;
else x = (pq.top() - op) / (fg ? (cnt + 1) : cnt);
错误写法：
ll x = ceil (1.0 * (pq.top() - op) / (fg ? (cnt + 1) : cnt));

涉及到1 << x 当x大于30或62时应该注意溢出可以写成1ull << x或1ll << x

二维计算的一些优化，对于一些0贡献的位置可以把他放在外层循环直接一起剪枝
for(int i = n - 1;i >= 3;-- i)
    for(int j = i + 1;j <= n;++ j)
      dp[i] = (dp[i] + cnt[j] * C(j - 1,i - 1)) % P;

for(int i = 3;i <= n;++ i)
  {
    if(!cnt[i])continue;
    for(int j = 3;j <= i - 1;++ j)
      dp[j] = (dp[j] + cnt[i] * C(i - 1,j - 1)) % P;
  }
当cnt为0时贡献为0这样可以直接剪枝掉减少循环次数

对大数减法计算的正确取模为：
a - b mod c = ((a - c) % mod + mod) % mod

快速幂在底数巨大的时候可以直接对底数取模
指数巨大直接欧拉降幂
对于逆元，如果你所需要的就是取整的效果就不需要取逆元，需要完整精度时才要取逆元